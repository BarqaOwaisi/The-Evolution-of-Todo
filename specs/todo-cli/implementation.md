# Implementation Contract: Evolution of Todo — Phase I
## (In-Memory Interactive Python Console Application)

Version: v1.0
Status: Binding and Final
Governing Docs:
- /sp.constitution
- /sp.specify
- /sp.plan
- /sp.tasks

## Purpose
This file defines the exact execution rules for implementing Phase I of the "Evolution of Todo" project using Claude Code and Spec-Kit Plus. It guarantees that all stated academic, architectural, functional, and UX requirements are fulfilled without deviation.

---

## Authoritative Rules (Non-Negotiable)

- Implementation MUST strictly follow the Agentic Dev Stack:
  Spec → Plan → Tasks → Implement
- No manual coding by humans is allowed.
- All code MUST be generated by Claude Code.
- No task, feature, or behavior may be added unless explicitly defined in governing specs.
- Any conflict is resolved in this order:
  1. /sp.constitution
  2. /sp.specify
  3. /sp.plan
  4. /sp.tasks

---

## Technology & Environment Enforcement

- Language: Python 3.12
- Environment manager: UV
- Frameworks: None (standard library only)
- Storage: In-memory only (no files, no DBs)
- Platform: Console / Terminal
- No networking, APIs, cloud, or persistence in Phase I

---

## Mandatory Application Behavior

### Startup & Authentication:
- On application start:
  - Prompt for user name
  - Prompt for password
- Authentication must:
  - Be validated against an in-memory user store
  - Repeat until valid credentials are entered
- On successful login:
  - Greet the user by name
  - Select a different greeting randomly each session

### CLI Interaction Model:
- CLI MUST be:
  - Interactive
  - Menu-based
  - Beginner-friendly
- Argument-based CLI flags are strictly forbidden.
- All interactions must occur through prompts and menus.

---

## Main Menu Requirements

The menu MUST:
- Display numbered options clearly
- Accept both:
  - Numeric input (e.g., `1`)
  - Natural language intent (e.g., "add task", "delete a todo")
- Be redisplayed after every action unless exiting

### Menu Options (Required):
1. Add a task
2. List all tasks
3. Update a task
4. Delete a task
5. Mark task complete / incomplete
6. Exit

### Exit Behavior:
- Exit must trigger when:
  - User selects menu option
  - User types `exit` or `quit`
- Exit must:
  - Display a friendly goodbye message
  - Confirm application termination
  - Cleanly end the session

---

## Functional Feature Enforcement (All Mandatory)

### Add Task:
- Prompt for title (required)
- Prompt for description (optional)
- Auto-generate unique task ID
- Store task in memory
- Confirm successful creation

### List Tasks:
- Display all tasks with:
  - ID
  - Title
  - Completion status
- Use clear visual indicators:
  - Completed → ✔ / [Done]
  - Incomplete → ✖ / [Pending]
- Handle empty task list gracefully

### Update Task:
- Prompt for task ID
- Validate task existence
- Allow updating title and/or description
- Confirm successful update

### Delete Task:
- Prompt for task ID
- Validate task existence
- Ask for confirmation before deletion
- Remove task from memory
- Confirm deletion

### Mark Complete / Incomplete:
- Prompt for task ID
- Toggle completion status
- Confirm new task state

---

## Error Handling & UX Rules

- Application must NEVER crash due to user input.
- All errors must be:
  - Human-readable
  - Non-technical
  - Helpful and corrective
- After any error:
  - System returns to main menu

---

## Architecture & Code Quality Rules

- Code must follow clean architecture:
  - UI / CLI layer
  - Business logic layer
  - Data/model layer
- Clear separation of concerns is mandatory.
- Code must be:
  - Readable
  - Beginner-friendly
  - Self-documenting
- All source code must live under `/src`.

---

## Deliverables Enforcement

Claude Code MUST produce:
- `/sp.constitution`
- `/specs/history` (all spec iterations)
- `/src` (Python source code)
- `README.md` (setup & usage)
- `CLAUDE.md` (Claude Code execution rules)

---

## Verification & Completion Criteria

Implementation is complete ONLY IF:
- All five core Todo features work correctly
- Menu-based interaction is fully functional
- Natural language and numeric inputs both work
- Authentication + greeting flow works
- No persistence exists
- Code structure matches the approved plan
- Every feature is traceable back to a spec decision

---

## Post-Implementation Restrictions

- No refactoring unless required to fix a spec violation
- No premature optimization
- No feature expansion beyond Phase I

---

## End of /sp.implement